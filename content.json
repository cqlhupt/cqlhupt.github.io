{"pages":[{"title":"friends","text":"","link":"/friends/index.html"},{"title":"关于我","text":"首先很高兴你能够到这个页面来，也希望我的博客可以帮到你。我是一个苦逼的大学狗，现在感觉比较迷茫，也不知到要干什么，于是搭建了这个博客。搭建期间VMware经常崩溃，于是废了很大的精力将虚拟机转为VirtaulBox虚拟机，但是VirtualBox的网络又不好和Ubuntu的运行又没有VMware流畅，要是你有什么好用的虚拟机软件请推荐给我，在此表示十分感谢。 如果我的博客对你有帮助我就感到无比的荣幸。 留下我的联系方式，如果你有什么问题，可以联系我，如果我可以解决自当竭尽全力。 E-mail: cquptlive@gmail.com QQ: 941191090 Facebook: Jhon Tony","link":"/about/index.html"}],"posts":[{"title":"APB总线学习","text":"这篇文章是APB总线学习的记录，说是记录其实是总线规范的翻译。APB总线是一个非流水线、低带宽、低复杂度的优化接口，用于挂载SoC内部的低速外设，如今广泛应用于各种SoC之中，是AMBA总线家族的一份子。AMBA总线是ARM公司推出的一系列用于搭建以ARM处理器为基础的SoC内部总线，由于如今嵌入式、移动端ARM处理器占比巨大，所以AMBA总线的占比也非常大。不过AMBA总线是公开的标准，不收取任何授权费用，所以也得到业内的广泛认可。 概述 一个低功耗、低复杂度的改良接口 低带宽、非流水线接口，不要求设备具有流水线接口 所有信号的变化都在上升沿，便于集成，每次传输至少两个周期 可配合AHB、AXI使用，可用于配置外设（好像系统中的设备都是通过APB配置，而不会用AXI、AHB配置？） 信号定义 名称 来源 描述 PCLK 时钟源 时钟，上升沿用于APB的所有传输 PRESETn 系统总线复位 复位，低电平有效，通常直接接到系统总线复位信号 PADDR APB桥 地址，APB地址总线，最多可以达到32位，由外设总线桥驱动 PSELx APB桥 选择，APB桥生成该信号用于不同的从机，当传输到来时表示从机的选中，每个从机都有一个，且互相排斥 PENABLE APB桥 使能，用于指示APB传输的第二个周期 PWRITE APB桥 方向，高表示写，低表示读 PWDATA APB桥 写数据，由APB桥在PWRITE信号为高时驱动，可以达到32位 PREADY 从机 就绪，从机用来扩展传输周期 PRDATA 从机 读数据，由APB桥在PWRITE信号为低时驱动，可以达到32位 PSLVERR 从机 表示传输失败，不是必要信号，当从机没有时，主机的该信号接地 写传输一、没有等待的写 传输由地址、写信号（拉高表示写）、片选信号、数据同时改变的时钟上升沿开始，该阶段称为建立阶段。下一个时钟沿使能信号生效，表示进入访问阶段。地址、写信号、片选信号、数据要保持到访问阶段结束。访问阶段结束意味着传输完成。使能信号在访问阶段结束时失效。片选信号也应当拉低，除非接下来的传输依然是给相同的外设。 二、有等待的写唯一的区别在于，当使能信号拉高后，外设通过拉低就绪（PREADY）信号扩展了访问阶段，延迟了传输的周期。在就绪信号为低时，所有的其他信号要保持不变。 当一次传输结束时推荐不要改变地址和写信号，保持到下一次传输到来时，这样可以降低（开关）功耗。 读传输一、无等待的读 主机将地址放在地址线上，将写信号拉低表示读、拉高片选信号，过一个周期之后拉高使能信号，同时从机将数据放在PRDATA线上并拉高PREADY表示数据就绪。 二、有等待的读同样，如果从机未准备好，那么可以拉低PREADY表示未就绪，使主机保持现有的信号直到从机就绪。 错误响应可以使用PSLVERR信号表示传输中的错误状况，读写都可以使用。 PSLVERR只在传输的最后阶段（PSEL, PENABLE, PREADY都为高）时才被考虑生效。 推荐（非强制）在传输的最后阶段前PSLVERR都保持低状态。 传输收到错误时，改不改变外设的状态取决于从机，且改不改变都是可以被协议接受的。写传输中出现错误不代表数据没被写进外设，读传输出错时可以返回不可用的数据，没有要求必须返回全0. 对于已存在或者新的APB外设都没有强制要求支持PSLVERR信号。当从机没有该信号时，APB桥（主机）的该引脚接到地即可。 错误向上映射 AXI2APB：APB错误映射为RRESP/BRESP=SLVERR，即将PSLVERR信号映射为RRESP[1]（读）和BRESP[1]（写） AHB2APB：APB错误映射为HRESP=ERROR，即将PSLVERR信号映射为HRESP[0]（读或写） 传输操作状态 状态 描述 IDLE 空闲状态 SETUP 当选择信号PSELx生效时，总线进入SETUP状态。总线只在该状态一个周期，下一个始终沿到来时进入ACCESS状态 ACCESS 使能信号PENABLE在该状态拉高，其他信号在SETUP变为ACCESS时必须保持稳定。ACCESS状态的退出收到从机的PREADY控制。当PREADY拉低时保持在ACCESS，当PREADY拉高后如果没有紧接着的传输就进入IDLE，否则直接进入SETUP开始下一次传输","link":"/2022/08/10/APB%E5%AD%A6%E4%B9%A0/"},{"title":"ESP-IDF建立Arduino组件项目","text":"Arduino是一个非常著名的开源开发板，是一款便捷灵活、方便上手的开源电子原型平台。包含硬件（各种型号的Arduino板）和软件（ArduinoIDE）。由一个欧洲开发团队于2005年冬季开发。其成员包括Massimo Banzi、David Cuartielles、Tom Igoe、Gianluca Martino、David Mellis和Nicholas Zambetti等。经过多年的发展，Arduino已经形成了一个庞大的生态，越来越多的硬件平台开始支持Arduino-IDE，乐鑫公司也为他们的ESP系列芯片提供了Arduino的支持，有两种方式：1. 在Arduino-IDE中安装esp开发板工具；2. 在ESP-IDF中将官方维护的Arduino包作为项目组件。 Arduino-IDE简介本篇的重点不是Arduino-IDE，所以这里简单介绍一下它的安装和使用。 Arduino-IDE下载Arduino提供Windows，Linux和MacOS的支持，我们可以直接前往官网下载安装包进行安装。 安装完成后，进入Arduino IDE 选择工具-&gt;开发板-&gt;开发板管理器，打开开发板管理器后搜索esp32，选择安装Espressif提供的esp32包 如果你的网络能够正常访问Github，那么应该一段时间后开发板包就会安装完成，但是由于国内的网络管控，更可能出现的情况是你需要等待很长时间，并且可能由于网络波动而失败。另外Arduino-IDE会将这些开发板包安装到你的C盘，导致你的C盘容量告急。以上也是我不太推荐这种方式的主要原因。 当你安装完毕之后可以在右下角的没有选择开发板处选择ESP开发板，并在编辑器窗口编写你的代码。 ESP-IDF组件在上一篇博客ESP-IDF环境搭建中介绍了在VS code中搭建ESP-IDF的方法，最终完成了使用官方例程hello_world进行打印的工作。 ESP-IDF中的project可以引入依赖组件，由于Arduino的开发便利性，语法也较为简答，所以乐鑫公司也提供了一个Arduino组件，让ESP的芯片可以使用Arduino的开发方式，大大降低开发和学习门槛，并且Arduino组件中包含了芯片中的硬件驱动供我们进行高抽象层级的调用。 首先打开VS code，按Ctrl + Shift + P，打开功能搜索框，搜索ESP-IDF:从扩展模板创建项目 选择项目存放目录 选择arduino_as_component 随后ESP-IDF开始创建项目 紧接着项目创建失败 这是由于ESP-IDF尝试从GitHub克隆arduino-esp32仓库，但是由于网络问题不能完成clone导致的失败，虽然组件仓库clone失败，但是其实IDF已经将项目的目录结构创建完成了，我们可以手动打开你刚才选择的项目文件夹，然后我尝试通过其他方式将仓库clone下来放到component文件夹中 整个arduino-esp32仓库有1.6GB，当我尝试clone时发现很多镜像都有1GB流量的限制，导致clone到1GB之后就会失败，最后我找到的一个方法是通过CSDN提供的GitHub仓库加速服务进行clone。希望CSDN看到后能给我打钱。最终将仓库clone下来放进component文件夹，然后尝试进行项目构建，遇到了一些小问题，我们后面还会提到，先说最大的一个问题。 目前的git clone下来的Arduino组件并不能支持最新的ESP-IDF版本，这也是前一篇搭建ESP-IDF环境时选择v5.1.4版本的原因。当我们使用最新的ESP-IDF尝试使用Arduino组件时，构建项目时会遇到如下问题（部分信息） 123456789101112131415161718E:/vstudio/esp32_example_project/arduino-as-component_bk/components/arduino/cores/esp32/esp32-hal-i2c-slave.c:319:3: error: implicit declaration of function 'i2c_ll_set_fifo_mode'; did you mean 'i2c_ll_set_data_mode'? [-Werror=implicit-function-declaration] 319 | i2c_ll_set_fifo_mode(i2c-&gt;dev, true); | ^~~~~~~~~~~~~~~~~~~~ | i2c_ll_set_data_modeE:/vstudio/esp32_example_project/arduino-as-component_bk/components/arduino/cores/esp32/esp32-hal-i2c-slave.c: In function 'i2c_slave_set_frequency':E:/vstudio/esp32_example_project/arduino-as-component_bk/components/arduino/cores/esp32/esp32-hal-i2c-slave.c:521:3: error: implicit declaration of function 'i2c_ll_cal_bus_clk'; did you mean 'i2c_ll_enable_bus_clock'? [-Werror=implicit-function-declaration] 521 | i2c_ll_cal_bus_clk(XTAL_CLK_FREQ, clk_speed, &amp;clk_cal); | ^~~~~~~~~~~~~~~~~~ | i2c_ll_enable_bus_clockE:/vstudio/esp32_example_project/arduino-as-component_bk/components/arduino/cores/esp32/esp32-hal-i2c-slave.c:526:3: error: implicit declaration of function 'i2c_ll_set_bus_timing'; did you mean 'i2c_ll_set_scl_timing'? [-Werror=implicit-function-declaration] 526 | i2c_ll_set_bus_timing(i2c-&gt;dev, &amp;clk_cal); | ^~~~~~~~~~~~~~~~~~~~~ | i2c_ll_set_scl_timingE:/vstudio/esp32_example_project/arduino-as-component_bk/components/arduino/cores/esp32/esp32-hal-i2c-slave.c:527:3: error: implicit declaration of function 'i2c_ll_set_filter'; did you mean 'i2c_ll_set_tout'? [-Werror=implicit-function-declaration] 527 | i2c_ll_set_filter(i2c-&gt;dev, 3); | ^~~~~~~~~~~~~~~~~ | i2c_ll_set_toutcc1.exe: some warnings being treated as errors 然后我去查看了错误信息中提到的文件以及函数，发现文件中确实没有定义这些函数，然后我就到Arduino仓库提了一个issue，后来官方回复说我使用的ESP-IDF版本不对，目前可用的应该是Arduino Release v3.0.6搭配ESP-IDF5.1.3版本。在我收到官方回复的当天他们又发布了Arduino Release v3.0.7 经过以上的踩坑我就发现一些问题： 乐鑫公司既然在ESP-IDF安装时可以选择国内的服务器，为什么不在国内提供一个可以下载arduino-esp32 release的地方 乐鑫公司在ESP-IDF创建arduino组件项目时为什么要尝试clone整个arduino-esp32仓库，而不是直接获取相应的release版本 希望以后能够有人能够解答我的疑问 随后我就发现另一条路：我们可以直接下载Arduino release压缩包，他只有几十MB，完全不能与整个仓库1.6GB相比，下载之后解压放到component文件夹中。然后再尝试构建整个项目。 尝试构建arduino_as_component 项目构建失败，原因如红框中所示 打开项目根目录下的sdkconfig文件，找到CONFIG_FREERTOS_HZ=100，将100改为1000 改完之后直接开始构建会遇到一个之前遇到过的问题 1ninja: error: loading 'build.ninja': 系统找不到指定的文件。 只需要删除构建之后再重新构建即可 总结到目前位置，我们已经完成了arduino_as_component的环境构建，可以在main.cpp文件中编写我们的业务代码，通过包含官方的驱动头文件调用我们需要的功能。 我们可以展开component文件夹中的文件，这里面包含了官方的库源码，当然也可以参考官方的文档。 最后附上一段使用ntp服务从阿里云获取时间并配置到芯片上打印到串口的程序。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &quot;Arduino.h&quot;#include &lt;WiFi.h&gt;#include &quot;time.h&quot; // 为了使用tm结构体#include &quot;esp_sleep.h&quot;const char *ssid = &quot;Mi 10S&quot;; // 请修改WiFi名称const char *password = &quot;qwertyur&quot;; // 请修改WiFi密码struct tm timeinfo;extern &quot;C&quot; void app_main(){ initArduino(); pinMode(4, OUTPUT); digitalWrite(4, HIGH); // Do your own thing Serial.begin(115200); Serial.printf(&quot;Connecting to %s &quot;, ssid); WiFi.begin(ssid, password); while (WiFi.status() != WL_CONNECTED) { delay(500); Serial.print(&quot;.&quot;); } Serial.println(&quot; CONNECTED&quot;); configTime(60*60*8, 0, &quot;ntp7.aliyun.com&quot;); // 用的阿里云的服务器 while (1) { /* code */ struct tm timeinfo; if(!getLocalTime(&amp;timeinfo)) { Serial.println(&quot;Failed to obtain time&quot;); return; } Serial.println(&amp;timeinfo, &quot;%A, %Y-%m-%d %H:%M:%S&quot;); delay(1000); } }","link":"/2024/11/03/ESP-IDF%E5%BB%BA%E7%AB%8BArduino%E7%BB%84%E4%BB%B6%E9%A1%B9%E7%9B%AE/"},{"title":"Hexo搭建","text":"经过一段时间的修复，现在我的博客恢复了。博客在几年前搭建好后，就一直处于吃灰状态，一直也没有更新过，不知道有没有人闯入过这里。这段时间准备重拾博客，发现原来的主题停止维护了，于是就换了一个，然后重新部署，虽然以前做了迁移准备，但还是折腾了几天，原因是迁移准备中的Hexo配置文件过时了，详情留待下次讲解吧。这篇文章是一篇Hexo搭建教程。 环境搭建 git Node.js hexo Github是著名的开源，同性交友社区，为广大用户提供了一个网上代码、博客托管空间，大约有300M空间，当然我们需要先在GitHub官网注册一个账户，在官网上就可以注册。当你注册好了，就可以开始搭建属于你自己的Hexo博客了。 安装gitgit是一个版本控制工具，和github搭配使用可以实现强大的功能。 Ubuntu系统： 1sudo apt install git -y Centos系统： 1sudo yum install git -y 安装Node.jsNode.js 是一个基于Chrome JavaScript 运行时建立的一个平台。 Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。 Ubuntu系统： 1sudo apt install nodejs -y Centos系统： 1sudo yum install nodejs -y 安装Hexo首先新建并进入一个文件夹： 123mkdir 文件夹名cd 文件夹名 安装Hexo： 1sudo npm install -g hexo-cli 安装主题 1sudo npm install hexo-theme-icarus 初次使用时需要初始化Hexo： 1hexo init 到这里，我们的博客本地基本上就搭建完毕了，你新建的文件夹就是博客的根目录，这个文件夹非常重要。 现在我们去看看我们的博客页面: 123hexo g //生成静态页面hexo s //启动本地服务，进行文章预览调试 这两个命令以后会比较常用，执行完后，不会结束，会提示你到：http://localhost:4000 查看你的博客页面 配置Github刚才我们在GitHub上注册的账户现在派上用场了，我们开始吧。 建立Repository进入Github官网登陆你的账户，点击右上角“+”号，选择New repository，第一项是仓库名，这个仓库将用于托管我们的博客静态页面，所以命名有讲究： 1你的用户名.github.io 然后点击Create repository即可。 回到我们的博客根目录，如果刚才**”hexo s”命令没有退出请按“Ctrl+c”**退出 编辑hexo配置文件： 1vim _config.yml 当然你也可以用其他的编辑器打开这个文件，修改文件的最后部分成如下： 1234567deploy:type: gitrepo: https://github.com/你的用户名/你的用户名.github.io.gitbranch: master 这样修改之后我们就将本地博客和我们的GitHub仓库关联在一起了，接下来的命令可以将我们的本地静态文件（前面：hexo g 生成的静态文件）推到GitHub仓库中，然后我们就可以通过：https://你的用户名.github.io 来访问你的博客了。 推送静态文件 1hexo d 到此我们的博客就部署完毕了，关于其他的像主题、头像什么的，这里就先不说了。不过我想说一说域名的绑定。 域名的绑定域名是为了帮助解决人们对于IP地址的记忆难题的一套机制，如www.baidu.com，www.alibaba.com，www.cqlh.ml都是域名，而IP地址是一串点分十进制数，如14.255.177.39，106.11.223.101，185.199.108.153等，显然前面两者更好记忆，我们可以给我们的博客绑定一个属于我们自己的域名，方便大家访问。 域名也是一种互联网资源，通常域名都是需要购买的，而且国内的域名大部分都是要备案的，而备案就需要有服务器，而且必须要使用期有三个月的服务器才可以用来申请备案，所以作为学生，我们就要想尽办法白嫖啊。 科学上网请使用Firefox浏览器，访问：https://addons.mozilla.org，在右上角搜索setup，找到SetupVPN Lifetime Free VPN，点击安装，然后这个插件将会出现在浏览器右上角，点击插件，然后注册一个免费帐户，然后选择一个节点连接。这里科学上网主要是为了访问下一步中的网站。 申请域名前往：www.freenom.com 注册一个账户用来申请免费域名 在首页检测自己想要的域名，由于是买免费的，所以后缀名可能不太常见，当然这个网站也出售收费域名 免费域名的期限是一年，在域名到期前15天可申请免费续订，如果要继续使用需要进行续订 将DNS设置到国内DNS是域名服务器，其实在网络中计算机使用的还是IP地址，DNS就是专门用来将域名翻译为IP地址的服务器，由于freenom是国外的的网站，所以其DNS在国外，在国内不能解析，所以我们要修改域名的DNS。 前往：https://www.dnspod.cn，注册一个账户或者使用QQ或微信登陆，进入域名解析–&gt;添加域名然后将域名写在下面的列表中，点击添加的域名，你将会看见两条记录，不要关闭该页面。 在freenom登陆账户后的首页，点击顶部的Service–&gt;My Domains，将看见你的域名，点击对应域名的**Manage Domain–&gt;Management Tools–&gt;Nameservers–&gt;Use custom nameservers (enter below)**。下面要求我们填写域名服务器，那么我们的域名服务器在哪呢？ 返回到DNSPOD页面，分别复制两条记录中的记录值项，填到Nameserver1和Nameserver2下面，然后点击Change Nameservers即可。 这样我们就吧我们域名的DNS服务器改为国内的DNSPOD，在国内我们就可以访问这个域名了，当然还要绑定我们的博客才能访问到博客。这个域名是在国外网站申请的，所以不用在国内进行备案，这样就简单了不少，备案至少需要15天，还不一定能申请下来。 创建CNAME文件回到博客根目录，进入source文件夹： 1cd source/ 创建CNAME文件： 1touch CNAME 将域名写到CNAME文件中，写的时候记得写域名前面的www 生成静态文件并推上GitHub： 123hexo ghexo d GitHub网页绑定域名在浏览器中访问GitHub官网并登录我们注册的账号，然后点击左边的repository中我们为博客建立的那个repository，点击在页面的中部右边的Setting，下滑找到GitHub Pages项，将你的域名填写在Custom domain中并点击Save。 添加域名解析记录 通过host命令查看我们博客部署的IP地址：1host 你的用户名.github.io 回到DNSPOD 域名解析 中点击我们刚才添加的 域名 点击添加记录，主机记录选择“@”，记录类型选择“A”，记录值填刚才host出来的IP地址，TTL设置为600（可变），然后保存。 点击添加记录，主机记录选择“www”，记录类型选择“A”，记录值填刚才host出来的IP地址，TTL设置为600（可变），然后保存。 到此，我们搭建好我们的博客，推上了GitHub并绑定了我们自己的域名。Hexo博客需要使用Markdown编写，不过Markdown语法比较少，也比较简单，可以参考：Markdown教程","link":"/2022/05/12/Hexo%E6%90%AD%E5%BB%BA/"},{"title":"Hexo博客迁移问题解决指南","text":"每次长期搁置博客之后恢复博客都会遇到一些坑，最好的方式当然是督促自己稳定更新，但是这就是另外一个问题了😂，还是来看看博客恢复的坑吧。 目录 可迁移Hexo 迁移到Windows 配置npm源 重新安装hexo和hexo-cli hexo g失败 public文件夹 配置git global 配置github公私钥 git timeout fatal icarus主题打开Latex支持 结语 可迁移Hexo当我们搭建完Hexo博客之后，会面临这样一个问题，如果搭建Hexo的本地环境出现了损坏，或者换了新的电脑，就需要将原来的Hexo迁移到新的平台，这是一个需要尽早考虑的问题，否则在积累一定的数据量之后迁移可能会造成数据的丢失。 可迁移的准备起始非常简单，由于在搭建Hexo时已经在github新建了一个用于托管博客的仓库，所以我们可以将我们博客的重要文件，例如主题、md文档，图片等资源都托管到Hexo仓库的另一个分支中，每次hexo deploy之后把相关的资料也git push到这个新分支中，以后如果需要迁移，那么直接从github将这个仓库clone下来，切换到该分支，然后重新安装hexo相关module即可完成平台迁移。 创建新分支： 12git clone &quot;Your Hexo github repository&quot; # 克隆你的Hexo仓库git checkout -b hexo # 创建并切换到名为hexo的分支，分支名称可以不同 将原来搭建hexo的目录内容复制到刚才创建的新分支目录下，并在.gitignore文件中填入以下内容 123456789.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/_multiconfig.ymlpackage* 通过以下命令提交并推送到github 123git add . # 添加所有非ignore文件到git管理git commit -a # 提交所有修改和添加的文件git push origin hexo # push新分支到github 迁移到Windows其实不管是Windows还是Linux，都可以迁移，不过目前我们日用的电脑一般都是Windows，所以这里着重讲迁移到Windows 首先你至少需要在Windows上安装以下软件 git node和npm 你可以访问他们的官网下载安装包进行安装 https://git-scm.com/downloads/win https://npm.nodejs.cn/cli/v8/configuring-npm/install 如果你的网络不能正常访问，你也可以考虑通过清华源下载： https://mirrors.tuna.tsinghua.edu.cn/github-release/git-for-windows/git/ https://mirrors.tuna.tsinghua.edu.cn/nodejs-release/ 配置npm源由于国内网络问题，可能对npm模块仓库访问很慢，甚至不能访问，所以需要配置npm国内镜像，以提高访问速度。这里我们可以选择不同的镜像，比如清华源npm或者npmmirror 镜像站，这里我选择了npmmirror 镜像站，执行如下指令 以下命令请在git bash中执行，打开git bash的目录是你clone下来的hexo仓库的hexo分支（或者你自己命名的新分支） 1npm install -g cnpm --registry=https://registry.npmmirror.com 执行完之后，后续我们可以用cnpm代替npm进行module的安装 重新安装hexo和hexo-cli通过前一节的配置我们可以通过以下命令安装hexo和hexo-cli 12cnpm install hexocnpm install hexo-cli hexo g失败理论上讲这时我们的迁移已经完成了，我们可以开始generate博客 1hexo g 此时你可能会遇到以下问题： Script load failed: themes\\icarus\\scripts\\index.js 解决办法是先执行一次hexo clean再执行hexo g 提示hexo版本不对 该问题一般在错误信息中会给出安装正确版本的命令，比如：npm install hexo^6.0.0 public文件夹public文件夹是在hexo s时生成的临时文件存放文件夹，在长期搁置博客之后你可能会忘记这件事，然后根据public的结构把资源放在其中，但是这会导致你编写完下一个博客后生成静态资源查看时丢失所有资源。正确的资源路径是你的主题文件夹下的source文件夹 配置git global当你编写好一个hexo博客之后想add和commit到本地仓库时，git会提示你配置global信息，以便确认你的身份，配置命令如下： 12git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;your.email@example.com&quot; 将双引号内的内容替换为你的github用户名和邮箱即可 配置github公私钥当你希望进行hexo d或者将本地改动push到hexo分支（你的新分支）时，会出现以下错误： 12345678On branch masternothing to commit, working tree cleangit@github.com: Permission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists.FATAL Something's wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html 这是由于没有配置github公私钥导致的，我们可以生成一个新的密钥对，把公钥上传到github，将私钥配置关联到本地仓库，然后就可以进行正常的deploy和push了 生成密钥对 1ssh-keygen –t rsa –C &quot;密钥注释&quot; 根据提示完成密钥的存储路径选择和密码输入，如果不需要密码可以直接回车两次 配置github公钥： 点击右上角你的头像并选择Settings，进入github网页的设置页面 点击SSH and GPG keys项再点击右侧的New SSH key，将你刚才生成的带_pub后缀的文件内容复制到表单中，并给这个公钥取一个名字 配置本地仓库关联私钥 123# 在你的hexo分支目录下打开git bashssh-agent bashssh-add &quot;你的私钥文件地址&quot; 随后即可开始进行博客部署和资源的提交 git timeout fatal在执行git push/pull时出现报错信息： 12345ssh: connect to host github.com port 22: Connection refusedfatal: Could not read from remote repository.​Please make sure you have the correct access rightsand the repository exists. 原因：GitHub的22端口（ssh默认端口）被屏蔽 解决方案：修改访问端口为443（https默认端口） 在用户目录下的.ssh文件夹中找到config文件（没有的话请新建一个），配置如下内容 1234Host github.comHostName ssh.github.com User gitPort 443 可以使用如下命令进行测试： 1234$ ssh -T git@github.comHi xxxxx! You've successfully authenticated, but GitHub does notprovide shell access.$ icarus主题打开Latex支持在你的主题配置文件中增加如下配置： 12plugins: mathjax: true 如果你使用的是主题默认配置文件，只需要在该默认文件中找到mathjax项，将其从false改成true即可 结语保持更新确实是一件很困难的事情，尤其是更新这件事本身对于自己可有可无的时候，毕竟人类的本质是鸽子和复读机。希望以后能够按时更新，记录自己的成长和生活。","link":"/2024/11/03/Hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%8C%87%E5%8D%97/"},{"title":"NAND Flash标准接口","text":"毕业也已经一年了，2021年11月拿到了现公司的offer，22年4月份应公司邀请提前到公司实习（主要是当时公司人太少了，我来了之后芯片设计一共5人，验证1人，项目开始后迟迟招不到人）。5月回校答辩，6月正式成为社畜打工人。由于工作安排，接受offer之后一直在熟悉NAND flash相关的接口，到目前为止，MPW芯片即将回片，虽然已经预见存在很多问题，不过已经完成了fullmask阶段的修改。NAND flash的接口与DDR SDRAM接口存在一定的相似性，在此记录以便巩固相关知识，也为后续工作和学习打下基础。 概述 JEDEC协会统一管理，分化出ONFi（开放）和Toggle（封闭） 具有和DDR SDRAM类似的接口 地址和数据复用同一组数据线（还未发布的JESD230G版本中可能会将二者分开） 信号定义 名称 来源 描述 CE_n 主控 片选信号，低电平有效，用于使能颗粒 ALE 主控 地址锁存使能信号，高电平有效 CLE 主控 命令锁存使能信号，高电平有效 WE_n/CLK 主控 SDR模式中写数据、命令和地址的边沿信号NVDDR模式中向颗粒输出持续时钟NVDDR2/NVDDR3/NVLPDDR4/Toggle模式中写命令和地址的边沿信号 RE_n/RE_n_c 主控 SDR模式中读数据边沿信号，用于采样NVDDR模式中指示读写高电平表示写，低电平表示读NVDDR2/NVDDR3/NVLPDDR4/Toggle模式中主控发送给颗粒的读数据的边沿信号互补信号RE_n_c仅在高速DDR时才开启 DQS/DQS_c 主控/颗粒 用于NVDDR/NVDDR2/NVDDR3/NVLPDDR4/Toggle模式的数据strobe信号写数据时其边沿位于DQ信号窗口的中间，由主控发往颗粒读数据时其边沿与DQ信号变化边沿对齐，由颗粒接收RE_n信号后返回给主控互补信号DQS_c仅在高速DDR时才开启 DQ[7:0] 主控/颗粒 数据信号，有8位和16位两种，16位的较为少见，且16位数据线在发送地址和命令时只使用低8位，只有在传输数据时才会使用全部16位数据线 WP_n 主控 写保护，低电平有效可复用为ODT控制线，用于主控控制颗粒的ODT使能时间而不是颗粒自动ODT Rb_n 颗粒 ready/busy信号，高电平表示ready，低电平表示busy * 此处的信号均为数字信号，如需了解电源相关模拟信号，请参考具体颗粒手册或ONFi协议 时序模式一、SDR/LegacySDR即Single Data Rate的缩写，在Toggle组织中也有将该模式称为Legacy的。在2006年的NAND市场混乱不堪，各家的接口标准和时序也不一致，当时的颗粒速率比较低，于是ONFi协会成立并发布的第一版ONFi协议。第一版协议中描述了该种工作模式，此工作模式下最高支持50MB/s。 命令锁存 CE_n信号拉低，对要操作的颗粒进行片选 CLE信号拉高，ALE信号保持低 主控端将命令放在DQ[7:0]上 主控控制WE_n产生一个边沿 从时序图中可以看到，时序参数均以WE_n的上升沿为参考，上升沿前的时间为建立时间（setup），上升沿后的时间为保持时间（hold）。只有WE_n拉低的时间为tWP，此参数取决于当前SDR工作的速率，其值为当前工作速率下的半个时钟周期，如工作于25MHz，则tWP应为20ns，数据速率则为25MB/s。 地址锁存 CE_n信号拉低，对要操作的颗粒进行片选 ALE信号拉高，CLE信号保持低 主控端将地址放在DQ[7:0]上 主控控制WE_n产生一个边沿 可以发现地址锁存时序与命令锁存时序非常相似，此处多出来的tWH参数其实和tWP参数一样，而tWC=tWP+TWH。tWH参数的引入主要是因为每次发送地址时总是含有多个Byte（目前主流的是5~6Byte，特殊操作会有10Byte），tWH描述的是两个Byte地址之间的间隔时间。 写数据 CE_n信号拉低，对要操作的颗粒进行片选 ALE信号和CLE信号保持低 主控端将数据连续放在DQ[7:0]上 主控控制WE_n连续产生与每个数据对应的上升沿 SDR写数据时，每个上升沿都是与数据相对应的，所以上升沿不能乱给，不然会导致数据顺序出错，在数据读出的时候会出现解码引擎无法完成解码的情况。时序参数增加了tCLH和tCH，规定的是最后一个数据写完之后CE_n和CLE信号需要保持的时间。 读数据 非EDO模式读 CE_n信号拉低，对要操作的颗粒进行片选 ALE信号和CLE信号保持低，主控端释放DQ[7:0]数据线（写数据时输出，读数据时输入） 主控端拉低RE_n信号 RE_n下降沿后经过tREA时间后，颗粒将数据放在DQ[7:0]上 主控端拉高RE_n信号，并使用上升沿对DQ[7:0]上的数据进行采样 重复3~5步，完成所有需要的数据采样 读数据时参考的时钟边沿是RE_n的上升沿，RE_n的周期（tRC）是工作时钟的周期，tRC=tRP+tREH。另一个重要的参数是tRR，因为在发完读数据命令之后到开始读数据之前，颗粒会处于Busy的状态（颗粒在此期间将数据从浮栅晶体管阵列中读出到缓存），在颗粒Ready之后到RE_n拉低之前的时间需要大于等于tRR。 EDO模式读 CE_n信号拉低，对要操作的颗粒进行片选 ALE信号和CLE信号保持低，主控端释放DQ[7:0]数据线（写数据时输出，读数据时输入） 主控端拉低RE_n信号 RE_n下降沿后经过tREA时间后，颗粒将数据放在DQ[7:0]上 主控端拉高RE_n信号，并下一个下降沿对DQ[7:0]上的数据进行采样 重复3~5步，完成所有需要的数据采样 观察时序图可以发现，此时tREA参数似乎长于非EDO的tREA，但是其实tREA参数对应于固定的一颗颗粒是比较一致的，只不过是我们提高了RE_n的速度（tRC变小了），看起来tREA相对变长了。这就带来一个问题，颗粒那边的数据输出是由下降沿触发的，采样数据的下降沿比触发数据下降沿晚一个周期，导致最后一个数据没有RE_n的下降沿进行采样。目前我的做法是将RE_n信号整体后延一个周期，再用来采样，也就是说将触发数据的下降沿沿延迟一个周期作为采样数据的下降沿，如果你有更好的方法，烦请与我交流，谢谢。 二、NVDDDR此模式为源同步模式，其接口与DDR SDRAM最为接近，包含了一个主控输出的同步时钟（WE_n/CLK）给颗粒，但是读写数据时仍需使用DQS信号，由于其相对于两外两种模式的复杂性和电气特性要求（主要是时钟信号、DQ信号、DQS信号的PCB等长布线，源同步时钟带来的功耗、高频干扰问题），目前已经没有颗粒厂商再研发相对应的颗粒，其速率也止步于100MHz DDR（200MB/s）。对此模式可以权当了解，无需深入。 命令锁存 CE_n信号拉低，对要操作的颗粒进行片选；ALE和CLE也拉低，并且保证三者拉低的时间相对于拉低后的第一个CLK上升沿满足途中tCS和tCALS参数 CLE信号拉高，ALE保持低，命令放在DQ[7:0]上 确保CLE拉高期间包含一个CLK上升沿，并满足tCALS和tCALH参数 可以发现，简单的一个命令锁存时序，已经包含相当多的时序参数，并且控制器内部是同步的数字电路，所有在控制过程中会给我们造成一定的麻烦。在控制时可以将CLE和ALE置于默认拉低的状态，让tCALS提前满足，CE_n用于片选，默认保持为高，需要使用时再拉低，tCAD参数则需要计数器。由于CLE中需要包含一个CLK的上升沿，所以CLK可以使用内部电路时钟的反相输出，这样的话内部控制信号变化时就对应CLK的下降沿。 地址锁存 CE_n信号拉低，对要操作的颗粒进行片选；ALE和CLE也拉低，并且保证三者拉低的时间相对于拉低后的第一个CLK上升沿满足途中tCS和tCALS参数 ALE信号拉高，CLE保持低，命令放在DQ[7:0]上 确保ALE拉高期间包含一个CLK上升沿，并满足tCALS和tCALH参数 地址锁存与命令锁存相似，不多赘述。 写数据 CE_n信号拉低，对要操作的颗粒进行片选；ALE和CLE也拉低，并且保证三者拉低的时间相对于拉低后的第一个CLK上升沿满足途中tCS和tCALS参数 拉低DQS，保持tWPRE时间 计数达到tCAD参数之后，ALE和CLE信号拉高，截取需要的CLK脉冲数量 ALE和CLE上升沿之后的第一个CLK上升沿开始计算tDQSS参数，满足后开始将数据放在DQ[7:0]上，并且保证DQS的边沿与数据的中心对齐 保持DQS拉低tWPST时间 这里出现了非常奇怪的一个时序，可以观察到的是ALE、CLE有效的时间和DQS、DQ[7:0]的有效时间是错开的，tDQSS时序是0.75~1.25倍的工作时钟周期，ALE和CLE截取的CLK周期应该与DQS输出的周期数量一致。可以看到tDQSS的时间正好落在负四分之一周期和正四分之一周期之间，由于DQS的边沿要和数据DQ[7:0]的中心对齐，所以我们使用DLL器件对截取出来的时钟进行延迟四分之一周期得到DQS，这样tDQSS时间至少会落在1.25倍时钟周期上，如果这个时序相当严格的话，那么非常容易违反。不过，如果延续之前的思路将内部时钟反相之后作为CLK输出，那么这个DQS的起始点可以落在0.75倍时钟周期上，可以满足要求。 这个时序明显是为了节省功耗而设计的，在ALE和CLE拉高一个周期之后（包含一个CLK上升沿，这个上升沿将会锁存ALE、CLE、W/R_n，所以这三个信号在时钟关闭之后就不关心了），关闭CLK时钟输出。同样的问题依旧存在，当我们重新打开CLK时，数据仍然没有送完，表明除了CLK输出控制发生变化之外其他的信号控制和数量均未发生变化。 此时序在上一个时序的基础上提供了一种数据暂停（非退出写数据去执行其他命令）等待的功能，即拉住DQS信号，让它不发生翻转。既然存在这种时序那是否意味着CLK没有停止的写数据时序是不能对DQS和数据进行暂停的。同时tDPZ是1.5倍时钟周期。 读数据 CE_n信号拉低，对要操作的颗粒进行片选；ALE和CLE也拉低，并且保证三者拉低的时间相对于拉低后的第一个CLK上升沿满足途中tCS和tCALS参数 拉低W/R_n信号，满足tCALS时间，保持tWRCK时间 计数达到tCAD参数之后，ALE和CLE信号拉高，截取需要的CLK脉冲数量 DQS和数据从颗粒返回，主控内部对DQS延迟四分之一个周期对数据进行双边沿采样这里又存在一个暂停的问题，如果主控内部的数据处理路径上出现了反压，那么是否能都通过拉低ALE、CLE进行流量控制，我倾向于是可以的，如果不能，那么这个时序将会给主控设计带来很大的挑战，因为他要求主控内部存在能够装得下一个Page的Buffer来避免遇到内部数据路径反压导致的数据断流。 总的来说，NVDDR已经成为时代的眼泪。NAND的接口最终还是转向了Toggle的时序。 三、NVDDR2/NVDDR3/NVLPDDR4/Toggle命令锁存命令的锁存与SDR的锁存时序基本一致，需要注意的点是此处的tWP时间不再是SDR模式下的半个周期，需满足tWP≥11ns，tWH≥11ns，tWC≥25ns。 地址锁存命令和地址的锁存时序基本一致，不赘述。 写数据 RE_n、WE_n、DQS保持高，对应差分信号保持低，ALE、CLE保持低 拉低CE_n，片选使能颗粒 拉低DQS，如果开启了差分，则同时拉高互补信号，保持tWPRE/tWPRE2时间 顺序输出数据和DQS，DQS边沿与数据中心对齐，可以通过拉住DQS来进行流量控制 数据输出完后，拉低DQS，保持tWPST时间 拉高CLE，经过tWPSTH时间后将颗粒的Program指令（如10h，每个颗粒厂商的命令不同）放在DQ上，拉低WE_n 经过tWP时间后，拉高WE_n，经过tCDQSH时间后释放DQS及其互补信号 可以看到，这里的时序是比较复杂的，其实我们可以将其拆分成两个部分，第15步是写数据，67步发Program命令。但是这两个操作不是完全分开的，它们通过DQS保持低联系在一起，因为通常DQS信号是保持高的，因为在写数据的初始状态要求DQS为高，所以主控在结束第一部分写数据操作后会想拉高DQS，这就造成了冲突，所以内部逻辑需要区分当前执行的操作是否在最后结束时能够把DQS给拉高。 这里ONFi和Toggle存在一定的区别，在使用ONFi标准的仿真模型上，确实检测了DQS的拉高时间，但是在Toggle标准的仿真模型上则没有做检查。 读数据 RE_n、WE_n、DQS保持高，对应差分信号保持低，ALE、CLE保持低 拉低CE_n，片选使能颗粒 拉低RE_n，如果开启了差分，则同时拉高互补信号，保持tRPRE/tRPRE2/tRPRE3时间 为了确保颗粒有反应，主控需要在tDQSD时间之后检查DQS是否被颗粒正常拉低* 主控开始输出RE_n的脉冲，可以通过拉住RE_n信号进行流控 经过tDQSRE时间，颗粒将接收到的RE_n信号作为DQS将数据带出来（DQS边沿与DQ变化沿对齐） 数据数量足够之后保持RE_n为低，持续时间为tRPST+tRPSTH，中间的分界是颗粒侧ODT关闭的时刻 * ONFi中RE_n拉低到DQS拉低的时间是tDQSD，最大值为18ns，Toggle中该时间则是tDQSRE，最大值为25ns。ONFi在读任何数据（read status/get feature/read data）时DQ上的第一个数据都是在DQS的第一个上升沿才出现在总线上的；Toggle只在read data时DQ上的第一个数据是在DQS的第一个上升沿才出现在总线上的，其他的读操作中，DQS拉低的时刻，第一个数据就会出现在DQ上，下一个下降沿DQ上会出现下一个数据，这种操作通常都是repeat twice的（一个DQS周期输出的数据是相同的）。 Dummy Toggle/Warmup随着颗粒工作频率的增加（400MHz以上，800MB/s以上），信号质量越来越难以得到保障，于是在协议中引入了一些保障信号质量的措施。 在读写数据前引入一些额外的RE_n和DQS周期，这些周期不包含有用数据，仅用于信号质量保障，在ONFi上称为warmup，在Toggle上称为dummy toggle。这个功能需要通过设置颗粒的参数来进行开启，默认一般不开启。目前支持的周期数量一般为1，2，4个。 写数据时，在输出DQS和数据前，先输出几个DQS周期，数据不用关心；同理在读数据时RE_n输出的前几个dummy周期也不会从颗粒带回正常数据，主控在获取这些无用数据后丢弃即可。 读写的Dummy Toggle是独立开关和配置的，二者可以配置不一样的dummy周期数量，ONFi协议中要求在800MB/s以上时需要开启该功能 读写数据暂停/退出（pause/exit）在正常的数据读写过程中，我们可能会遇到需要中断传输释放IO，处理主控内部信息，调整主控内部状态等。NVDDR234模式下提供了一种退出当前数据传输的方法，就是在数据传输需要中断时，拉高CE_n/ALE/CLE退出传输，重启传输时，将CE_n/ALE/CLE拉低即可。 此退出功能与拉住DQS和RE_n的流控不同，在重启传输时，如果开启了dummy toggle，则需要重新发送额外的RE_n/DQS周期，后者不需要重新发送dummy toggle。 颗粒在800MB/s以上工作时，如果传输退出超过1μs未恢复，则颗粒可以要求重启时主控端需要先发送Change Read Column/Change Read ColumnEnhanced命令，由颗粒厂商决定，请参考具体颗粒数据手册。 ODT（On Die Termination） 高速信号在阻抗不连续的导体之间会出现信号反射，为了防止反射信号对后续传输的码字产生影响，在颗粒内部引入了片上端接电阻，此电阻可以配置，以适应各种状态下的信号反射。 ODT用于RE_n/RE_n_c、DQS/DQS_c、DQ[7:0]（即颗粒接收的所有高速信号），命令和地址的发送不使用ODT。 ODT分为Self Termination和Matrix Termination，我的理解是前者只使用当前操作的Die内部的端接电阻进行端接，而后者可以使用相同CE_n下其他Die的端接电阻配合当前Die进行端接。Matrix Termination具有更强的灵活性。 ONFi5.0协议上更新了NVLPDDR4接口的电气特性，包括新的端接方式，如上图中描述的NVDDR2/3使用的均为CTT（中心端接），NVLPDDR4则需要使用LTT（低端端接）。","link":"/2023/08/12/NAND%20Flash%E6%A0%87%E5%87%86%E6%8E%A5%E5%8F%A3/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/04/12/hello-world/"},{"title":"ESP-IDF环境搭建","text":"ESP-IDF(ESP IoT Development Framework)是乐鑫公司推出的开源ESP32开发框架，支持通过VS code插件安装，具有完善的文档，并且支持配置Arduino为项目组件，可以极大降低开发难度，使初学者快速上手。但是在安装过程中仍遇到一些问题，主要与国内的网络环境相关，编写这篇博客记录一下安装使用过程中遇到的坑和解决办法。 目录 起因 第一次搭建 Hello World工程 更便宜的ESP 起因前一段时间在研究蓝牙打卡时心血来潮斥巨资购买了一块esp32c3开发板，用于研究蓝牙广播（后来发现嘉立创新用户购买更便宜，后面再说）。我参考的教程是钉钉蓝牙打卡，根据作者的描述，我们需要两块开发板，我就先买了一块准备进行学习，一方面节约资金，一方面我在考虑另一套方案。如果你是一个有素养的嵌入式攻城狮，那么你大概率手里有USB转串口设备，此时你可以选择购买简约版（不自带串口），当然你也可以购买经典版，它有即插即用的优势。 第一次搭建作为忠实的VS code用户，能用插件解决的问题都用插件解决，所以我准备参考网上的教程安装。首先需要准备VS code，如果你的计算机上没有VS code，你可以前往官网下载安装，如果你使用的是Windows，那么你还可以前往微软商店搜索安装。 安装完VS code之后，打开VS code并进入插件搜索界面 点击安装，等待安装完成，安装完成后左侧快速访问栏中出现插件的logo，点击插件logo，如果安装完成后没有看见logo，请点击快速访问中的三个点然后选择ESP-IDF：资源管理器 点击Configure extentions，进入ESP-IDF的真正安装界面 界面中有三个选项，从上到下分别是 快速安装：选择ESP-IDF，ESP-IDF Tool以及python安装路径进行安装 高级安装：选择ESP-IDF，ESP-IDF Tool以及python安装路径以及每个ESP-IDF Tool的安装路径 使用已经安装的ESP-IDF配置 我们选择快速安装即可，进入安装界面 安装说明： Select download server：选择Espressif(Better speed for China)，如果你的网络可以正常访问Github也可以选择Github Select ESP-IDF version：选择ESP-IDF版本，目前建议选择v5.1.4，由于我已经安装了v5.1.4，所以这里用v5.2.3作为示例 Enter ESP-IDF container directory：选择ESP-IDF容器安装文件夹 Enter ESP-IDF Tools directory(IDF_TOOLS_PATH)：选择ESP-IDF工具安装文件夹 两个安装文件夹尽量选择非C盘，因为Windows的某些机制导致系统内的应用都疯狂的想占领C盘，但C盘的空间往往并不富裕，当然如果你恰好颇有家资请当我没说。配置完成后点击右下角Install即可，等待安装完毕。 Hello World工程安装完毕后回到插件的起始界面，点击Show examples，编辑器上方弹出EDF-IDF工具选择，点击图中的2处我们安装ESP-IDF的路径，这个路径是我们刚才安装的，如果你安装了多个版本的ESP-IDF，可以点击Configure extentions在通过界面中的使用已经安装的ESP-IDF配置进行选择 随后进入示例工程选择界面，这里包含官方提供的各种例程，包括例程的介绍和支持的芯片，后续可以通过阅读这些例程深入学习相关的使用方法，现在我们就选择hello_world工程进行创建 选择我们的开发板芯片esp32c3，然后点击Create project using example hello_world，随后选择一个文件夹，创建时工具会自动在该文件夹下创建一个新文件夹并将例程文件放在其中，所以建议新建一个文件夹专门用于放置ESP-IDF的项目 点击底部的小扳手构建项目，然后出现了报错，提示build.ninja文件找不到，我们点击扳手左边的垃圾桶来清除构建，然后再点击扳手重新构建项目即可成功构建 第一次搭建环境即告完成，现在我们可以使用USB数据线将开发板连接到计算机，然后通过左下角的COM口配置选择开发板的串口号，串口号可能不一样，如果你购买的是简约版，那么你需要选择你的USB转串口设备的串口号，并将USB转串口设备通过杜邦线链接到开发板的串口引脚 点击图中3处标记的闪电，初次烧录程序会弹出烧录方式选择，我们选择UART即可，后续如果需要改变烧录方式可以通过点击闪电左边的五角星来改变。随后工具开始烧录程序 烧录完成后会有如下提示： 12Flash Done ⚡️Flash has finished. You can monitor with ESP-IDF: Monitor your device command 点击闪电右边的显示器按钮，就可以看到开发板打印出来的信息 更便宜的ESP在购买了esp32c3开发板之后，突然发现立创商城提供新用户优惠，可以1元购买ESP32-WROOM-32模块，虽然需要付邮费，但是可以选择比较经济的邮寄方式，并且有邮费减免，最终实付3元。希望嘉立创看到的话能够给我打钱😉","link":"/2024/11/01/ESP-IDF-environment-setup/"},{"title":"Python获取BLE广播","text":"蓝牙协议从1999年发布第一版以来已经二十几个年头，也随着移动通信的发展普及到我们生活的方方面面，并且在可见的未来将会随着物联网和边缘计算渗透到我们肉眼可见不可见的各个角落。在蓝牙4.0中，蓝牙技术联盟（Bluetooth SIG）引入了BLE（Bluetooth Low Energy）协议，该协议以极低的功耗优势进入物联网设备领域。本篇就一起看一下，如何在Windows使用Python读取周围BLE设备发出的广播（advertisement）。 nRF Connect如果你调试过BLE设备，那么nRF Connect软件你应该并不陌生，它是由NORDIC SEMICONDUCTOR公司开发的一款跨平台BLE连接性测试应用。他们也设计各种射频相关的Soc，你可以购买他们的评估或者开发套件用于测试与开发。 通过移动版的nRF Connect应用可以轻松的对附近的蓝牙设备进行扫描，并且不依赖于任何外部硬件设备。如果你使用的是Android设备，你可以前往Google Play或者Github下载相应的安装包文件进行安装，如果你使用的是苹果设备请前往App Store下载应用。 nRF Connect应用启动页面如下，软件需要打开定位和蓝牙方可开始扫描 我们打开定位和蓝牙就可以看到右上角的SCAN按钮，然后点击按钮即可对周围的蓝牙设备进行扫描 点击设备列表中的设备可以展开查看设备的广播信息 点击信息的RAW按钮，即可查看该设备广播的RAW数据是什么 Raw data解析之后就是Details表格中的内容，实际上raw data的组织是很简单的，raw data是按照多个固定顺序排列的数据结构构成的： 第1字节是type和value的字节数量 第2字节是type，是蓝牙技术联盟指定的内容类型 后续字节是value，即数据载荷 重复以上数据结构，即组成raw data，我们也可以根据规则对raw data进行解析，这个我们后续会用到。 nRF Connect的功能非常强大，不过今天不准备再介绍它了。nRF Connect虽然功能强大，不过目前较为普遍的使用都是手机端的，桌面端的需要一个他们公司的适配器才能进行周围的设备扫描，另外一个缺点是手机端应用需要开启定位，虽然我也不知道它为什么要定位，不过对于需要定位的应用我总是觉得不是很放心。所以接下来我们开始介绍Python的蓝牙库，最终实现在Windows上直接获取BLE的RAW广播。 Python的蓝牙库如果你希望使用Python实现某个功能，那么你要先寻找一个相应的库，然后在代码中引入这个库。接下来我们看一下各位大神都给我们造好了哪些轮子吧。 pybluezpybluez支持Windows和Linux下的经典蓝牙，仅在Linux下支持BLE。由于不同操作系统对于硬件的驱动方式不同，所以一个处于高层的库需要更底层的库依赖，或者对底层的库进行封装。你可以前往PyBluez官方文档查看如何进行安装。 pybluez的安装相当麻烦，在windows上需要安装Microsoft Visual C++ 14.0，这个其实我难以理解，为什么某些操作系统上层的应用会以操作系统的应用开发工具为依赖，这种依赖方式在你安装了各种不同的应用之后会发现你的程序管理器中多出一大堆不同版本的Microsoft Visual C++，有些应用甚至直接让你安装一个Microsoft Visual Studio开发环境，如果你遇到不同应用之间的依赖版本冲突则堪称噩梦，因为此时你虽然只想把当前这个应用安装好，但是你必须弄清楚以前安装的应用的依赖分别是哪些，以及会不会有版本冲突。 安装完成后我们可以使用如下代码进行测试 1234567891011121314151617181920212223242526272829303132333435#server端from bluetooth import *server_sock=BluetoothSocket( RFCOMM )server_sock.bind((&quot;&quot;,PORT_ANY))server_sock.listen(1)port = server_sock.getsockname()[1]uuid = &quot;94f39d29-7d6d-437d-973b-fba39e49d4ee&quot;advertise_service( server_sock, &quot;SampleServer&quot;, service_id = uuid, service_classes = [ uuid, SERIAL_PORT_CLASS ], profiles = [ SERIAL_PORT_PROFILE ], # protocols = [ OBEX_UUID ] ) print(&quot;Waiting for connection on RFCOMM channel %d&quot; % port)client_sock, client_info = server_sock.accept()print(&quot;Accepted connection from &quot;, client_info)try: while True: data = client_sock.recv(1024) if len(data) == 0: break print(&quot;received [%s]&quot; % data)except IOError: passprint(&quot;disconnected&quot;)client_sock.close()server_sock.close() 123456789101112131415161718192021222324252627282930313233343536373839404142# client端from bluetooth import *import sysif sys.version &lt; '3': input = raw_inputaddr = Noneif len(sys.argv) &lt; 2: print(&quot;no device specified. Searching all nearby bluetooth devices for&quot;) print(&quot;the SampleServer service&quot;)else: addr = sys.argv[1] print(&quot;Searching for SampleServer on %s&quot; % addr)# search for the SampleServer serviceuuid = &quot;94f39d29-7d6d-437d-973b-fba39e49d4ee&quot;service_matches = find_service( uuid = uuid, address = addr )if len(service_matches) == 0: print(&quot;couldn't find the SampleServer service =(&quot;) sys.exit(0)first_match = service_matches[0]port = first_match[&quot;port&quot;]name = first_match[&quot;name&quot;]host = first_match[&quot;host&quot;]print(&quot;connecting to \\&quot;%s\\&quot; on %s&quot; % (name, host))# Create the client socketsock=BluetoothSocket( RFCOMM )sock.connect((host, port))print(&quot;connected. type stuff&quot;)while True: data = input() if len(data) == 0: break sock.send(data)sock.close() bluepy仅支持Linux的BLE蓝牙库，不需要底层操作系统依赖，直接通过pip安装即可： 1sudo pip install bluepy 官方文档中有一些DEMO可以参考，也可以参考bluepy_examples_nRF51822_mbed 有一点需要注意，在Linux下使用bluepy要使用sudo前缀，由于bluepy只支持Linux，所以先不做介绍。 bleak来到本篇的重点，bleak是一个异步的BLE库，支持Windows和Linux，也不依赖任何Windows开发环境，直接依赖于Windows提供的Runtime环境。 直接通过pip安装 1pip install bleak 直接扫描周围的BLE设备 123456789import asynciofrom bleak import BleakScannerasync def main(): devices = await BleakScanner.discover() for d in devices: print(d)asyncio.run(main()) 使用client类连接设备进行操作 123456789101112import asynciofrom bleak import BleakClientaddress = &quot;24:71:89:cc:09:05&quot;MODEL_NBR_UUID = &quot;2A24&quot;async def main(address): async with BleakClient(address) as client: model_number = await client.read_gatt_char(MODEL_NBR_UUID) print(&quot;Model Number: {0}&quot;.format(&quot;&quot;.join(map(chr, model_number))))asyncio.run(main(address)) 如果你想获取一些广播中的信息，你可以在discover方法中传入一个参数： 1devices = await scanner.discover(return_adv=True) 将return_adv参数设为True之后，discover将会返回一个Dictionary，其key是蓝牙设备的地址字符串，其value是一个Tuple，该Tuple包含两个对象，第0个对象是BLEDevice，第1个对象是AdvertisementData，也许你觉得到此我们就可以获取到地址对应的广播数据了（advertisement），但是bleak的作者告诉我，并不能。 我们可以先看一下python安装目录\\Lib\\site-packages目录中的bleak的AdvertisementData类 观察类的内部属性，对比蓝牙技术联盟提供的Assigned Numbers文档2.3节，发现该类中的属性是将部分重要的Assigned Numbers对应的数据。我们还可以在目录中找到一个assigned_numbers.py文件，这里面就是bleak可以解析的Assigned Numbers 可以发现，bleak支持解析的Assigned Numbers其实很少，如果我们直接通过AdvertisementData类获取advertisement，就可能会出现bleak不支持的类型无法获取的问题，如下是目前较为完整的Assigned Numbers列表 12345adv_type_list = {0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A ,0x0D,0x0E,0x0F,0x10,0x11,0x12,0x14,0x15,0x16,0x17 ,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,0x20,0x21 ,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2A,0x2B ,0x2C,0x2D,0x2E,0x2F,0x30,0x31,0x32,0x34,0x3D,0xFF} 那么我们如何才能获取到完整的广播呢，不如直接到Github上提个issue问一下吧，看看作者如何解答：bleak/issues/1678 非常遗憾，bleak并不提供这样的接口，不如来看看bleak是如何解析Windows返回的advertisement的吧。打开bleak\\backends\\winrt\\scanner.py文件，找到BleakScannerWinRT类中的_received_handler方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697def _received_handler( self, sender: BluetoothLEAdvertisementWatcher, event_args: BluetoothLEAdvertisementReceivedEventArgs,): &quot;&quot;&quot;Callback for AdvertisementWatcher.Received&quot;&quot;&quot; # TODO: Cannot check for if sender == self.watcher in winrt? logger.debug(&quot;Received %s.&quot;, _format_event_args(event_args)) # REVISIT: if scanning filters with BluetoothSignalStrengthFilter.OutOfRangeTimeout # are in place, an RSSI of -127 means that the device has gone out of range and should # be removed from the list of seen devices instead of processing the advertisement data. # https://learn.microsoft.com/en-us/uwp/api/windows.devices.bluetooth.bluetoothsignalstrengthfilter.outofrangetimeout bdaddr = _format_bdaddr(event_args.bluetooth_address) # Unlike other platforms, Windows does not combine advertising data for # us (regular advertisement + scan response) so we have to do it manually. # get the previous advertising data/scan response pair or start a new one raw_data = self._advertisement_pairs.get(bdaddr, _RawAdvData(None, None)) # update the advertising data depending on the advertising data type if event_args.advertisement_type == BluetoothLEAdvertisementType.SCAN_RESPONSE: raw_data = _RawAdvData(raw_data.adv, event_args) else: raw_data = _RawAdvData(event_args, raw_data.scan) self._advertisement_pairs[bdaddr] = raw_data uuids = [] mfg_data = {} service_data = {} local_name = None tx_power = None for args in filter(lambda d: d is not None, raw_data): for u in args.advertisement.service_uuids: uuids.append(str(u)) for m in args.advertisement.manufacturer_data: mfg_data[m.company_id] = bytes(m.data) # local name is empty string rather than None if not present if args.advertisement.local_name: local_name = args.advertisement.local_name try: if args.transmit_power_level_in_d_bm is not None: tx_power = args.transmit_power_level_in_d_bm except AttributeError: # the transmit_power_level_in_d_bm property was introduce in # Windows build 19041 so we have a fallback for older versions for section in args.advertisement.get_sections_by_type( AdvertisementDataType.TX_POWER_LEVEL ): tx_power = bytes(section.data)[0] # Decode service data for section in args.advertisement.get_sections_by_type( AdvertisementDataType.SERVICE_DATA_UUID16 ): data = bytes(section.data) service_data[normalize_uuid_str(f&quot;{data[1]:02x}{data[0]:02x}&quot;)] = data[ 2: ] for section in args.advertisement.get_sections_by_type( AdvertisementDataType.SERVICE_DATA_UUID32 ): data = bytes(section.data) service_data[ normalize_uuid_str( f&quot;{data[3]:02x}{data[2]:02x}{data[1]:02x}{data[0]:02x}&quot; ) ] = data[4:] for section in args.advertisement.get_sections_by_type( AdvertisementDataType.SERVICE_DATA_UUID128 ): data = bytes(section.data) service_data[str(UUID(bytes=bytes(data[15::-1])))] = data[16:] # Use the BLEDevice to populate all the fields for the advertisement data to return advertisement_data = AdvertisementData( local_name=local_name, manufacturer_data=mfg_data, service_data=service_data, service_uuids=uuids, tx_power=tx_power, rssi=event_args.raw_signal_strength_in_d_bm, platform_data=(sender, raw_data), ) device = self.create_or_update_device( bdaddr, local_name, raw_data, advertisement_data ) self.call_detection_callbacks(device, advertisement_data) 观察_received_handler方法的定义发现它有3个参数，self是当前调用该方法的对象，剩下两个分别是BluetoothLEAdvertisementWatcher对象和BluetoothLEAdvertisementReceivedEventArgs对象。除了self之外，另外两个参数都是Windows Runtime环境提供的对象，表明该函数是直接与Windows系统交互的。 在代码第15行，定义了bdaddr变量，从BluetoothLEAdvertisementReceivedEventArgs对象中取得了BLE设备地址并进行了格式化。再看第17、18行作者写的注释：不像其他的平台，Windows不会组织advertisement信息，所以我们需要自己处理。这行注释表明该方法将会处理Windows系统返回的advertisement信息。第21行到第29行尝试获取对应bdaddr地址的BLE advertisement raw，并更新本对象的_advertisement_pairs属性中bdaddr键对应的值。第31到35行创建了一些临时变量，可以发现这些变量都是Assigned Numbers对应的数据，这些变量在第83行用于创建了一个我们前面提到的AdvertisementData对象（discover方法的部分返回值）。接下来是一个嵌套的for循环，在循环中获取了BluetoothLEAdvertisementReceivedEventArgs对象内部的advertisement属性，该属性是BluetoothLEAdvertisement类对象，其内部构造如下 bleak在嵌套的for循环中获取了BluetoothLEAdvertisement类内部的service_uuids，manufacturer_data，local_name属性，又通过get_sections_by_type方法获取了tx_power（发射功率），service_data，最终将填充好的变量和raw_data一起构造了一个AdvertisementData对象，随后在93行调用了create_or_update_device方法，更新了self对象属性，最后调用用户传入的回调函数 到这里我们可以发现，当我们在discover方法中传入return_adv=True参数后我们其实可以拿到AdvertisementData对象，而AdvertisementData对象中platform_data属性就是在刚才_received_handler方法中传入的，platform_data是一个Tuple，其第[1]个元素就是raw_data，raw_data是一个_RawAdvData对象，_RawAdvData对象中有adv和scan属性 12345678910111213141516class _RawAdvData(NamedTuple): &quot;&quot;&quot; Platform-specific advertisement data. Windows does not combine advertising data with type SCAN_RSP with other advertising data like other platforms, so se have to do it ourselves. &quot;&quot;&quot; adv: BluetoothLEAdvertisementReceivedEventArgs &quot;&quot;&quot; The advertisement data received from the BluetoothLEAdvertisementWatcher.Received event. &quot;&quot;&quot; scan: Optional[BluetoothLEAdvertisementReceivedEventArgs] &quot;&quot;&quot; The scan response for the same device as *adv*. &quot;&quot;&quot; adv是BluetoothLEAdvertisementReceivedEventArgs对象，具有advertisement属性，advertisement属性是BluetoothLEAdvertisement对象，具有DataSections属性，这个属性在winrt转成python对象之后变成data_sections，该属性包含了BLE设备advertisement的所有字段，我们可以直接解析这个属性，它是一个包含BluetoothLEAdvertisementDataSection类对象的列表，BluetoothLEAdvertisementDataSection类中有两个属性data和data_type，其中data_type就是Assigned Number，data则是Assigned Number对应的Byte内容 到此我们通过一个超长的对象引用链，最终拿到了我们想要的advertisement数据 bleak获取advertisement示例123456789101112131415161718192021222324import asyncioimport bleakfrom bleak import BleakScannerimport binasciiasync def ble_scan(): scanner = BleakScanner() devices = await scanner.discover(return_adv=True) for d in devices: print(f&quot;mac addr: {devices[d][0].address}, name: {devices[d][0].name}&quot;) for args in filter(lambda d: d is not None, devices[d][1].platform_data[1]): sec_set = [] for j in args.advertisement.data_sections: j_set = [int(j.data_type), bytes(j.data)] flag = False for s in sec_set: flag = (s == j_set) if (flag == False): sec_set.append(j_set) for sec in sec_set: print(f&quot;Type: {'{:02X}'.format(sec[0])}\\tPayload: {''.join(['%02X' % b for b in sec[1]])}&quot;)asyncio.run(ble_scan()) 123456789101112131415161718192021222324252627# outputmac addr: 81:26:00:00:07:03, name: LuYuan-SmartType: 01 Payload: 06Type: 19 Payload: C003Type: 03 Payload: 1218Type: FF Payload: 812600000703Type: 0A Payload: 00Type: 09 Payload: 4C755975616E2D536D617274mac addr: 5A:53:C9:75:58:C7, name: NoneType: 01 Payload: 1AType: 0A Payload: 0CType: FF Payload: 4C0010060D1D2229AB38 mac addr: 4D:69:42:97:E4:E4, name: NoneType: 01 Payload: 1AType: 0A Payload: 0CType: FF Payload: 4C001005051C237DA3mac addr: D7:C4:BA:B5:3F:6C, name: NoneType: FF Payload: 4C0012020002mac addr: 66:84:61:36:6D:6F, name: NoneType: 01 Payload: 1AType: 0A Payload: 0BType: FF Payload: 4C001005711C7D9A6Amac addr: D0:62:2C:CC:F4:0E, name: NoneType: 01 Payload: 06Type: 19 Payload: C200Type: 16 Payload: 95FE1059282E000EF4CC2C62D0Type: 16 Payload: ABFD0103 在for循环中输出了data_sections的内容，我们也可以直接将数据重新组装为raw。 结论通过如上的分析，我们从bleak到Windows Runtime环境，最终获取到我们想要的数据。到此，也许如何获取advertisement RAW已经不再重要，重要的是我们了解到一条可以让python通向Windows操作系统底层的路径，该条路径以后可以帮助我们直接操作Windows的API，用以自己构建相应的python库。 在这里也祝贺川建国同志赢得大选，继续为世界人民带来乐子😂","link":"/2024/11/06/Python%E8%8E%B7%E5%8F%96BLE%E5%B9%BF%E6%92%AD/"},{"title":"AHB学习","text":"AHB是新一代AMBA总线，旨在满足高性能可综合设计的要求。AHB是支持多主机和高带宽操作的高性能总线。学习AHB对我们设计和使用AMBA总线兼容模块具有重要意义。作为AMBA总线的一部分，在芯片中得到了广泛的应用，学习总线，理解总线能让我们在设计模块时游刃有余。 AHB学习AHB为高性能、高时钟频率系统实现了如下特性： 突发传输 拆分事务 单周期总线移交 单边沿操作 非三态实现 数据总线宽度可配置 AHB和ASB/APB的桥接能够非常高效以确保任何现存的设计能够便于集成。 一个基于AHB总线的系统包含一个或多个主机，典型系统中至少包含处理器和测试接口（作为主机）。然而，DMA和DSP也是常见的总线主机。 外部存储器接口、APB桥和任何内部存储器都是常见的AHB从机。任何其他的外设都应当被认为是AHB的从机。但是，低带宽外设通常作为APB的从机。 典型的AHB系统包含如下组件：AHB主机：主机可以通过提供地址和控制信息来发起读写操作。一次只能有一个主机激活并使用总线。AHB从机：一个从机在一个指定的地址空间内响应读写请求。从机返回信号给主机表示成功、失败或者等待数据传输。AHB仲裁器：仲裁器用于确保同一时间只有一个主机使用总线发起数据传输。尽管仲裁协议是固定的，仲裁算法（固定优先级、循环优先级）却可以根据不同的应用场景来实现。一个AHB应只包含一个仲裁器，尽管这在单主机系统中比较琐碎。AHB译码器：用于在数据传输中进行地址译码并向传输中将会用到的从机发送选择信号。在AHB系统中要求只有一个中央译码器。 AHB总线结构AHB总线系同一般由几个部分组成：主机，仲裁器，地址译码器，从机 这里的slave接口中只有一个HREADY，实际上我们需要一个HREADY_out和一个HREADY_in，用于避免在总线移交到另一个slave时上一个slave把HREADY_out拉低而延长传输周期 实际上master和slave是比较常用的，另外两个基本上只有做总线互联的时候会用到，一般的公司很少进行总线互联的研发，一般有两种情况会研发总线互连，一是公司被制裁，不能购买成熟的总线互联IP，另一种是公司产品本身就是以总线互联IP AHB信号列表AHB总线信号简述，所有的信号都以H开头以区别系统中其他相似的信号 name source description HCLK 时钟源 时钟，上升沿用于AHB的所有传输 HRESETn 复位控制器 复位，唯一低电平有效的信号，用于复位系统和总线 HADDR[31:0] 主机 地址，32位系统地址总线 HTRANS[1:0] 主机 指示当前传输类型，可以是NONSEQUENTIAL, SEQUENTIAL, IDLE或BUSY HWIRTE 主机 高表示写传输，低表示读传输 HSIZE[2:0] 主机 指示传输数据的宽度，常为字节(8-bit)、半字(16-bit)或字(32-bit)。协议允许最大值为1024bit，但必须小于等于数据总线宽度。 HBURST[2:0] 主机 指示突发传输的形式，自增（increment）和环回（warp）都支持4、8、16拍传输。 HPROT[3:0] 主机 保护控制信号提供关于总线接入的附加信息，并主要用于希望实现某种级别保护的模块。信号指示传输是否是操作码拾取（opcode fetch）或数据访问（data access），以及传输是特权模式（privileged mode）还是用户模式（user mode）。对于带有MMU的总线主机来说还用于指示当前访问的数据是否可以缓存（cacheable）或缓冲（bufferable） HWDATA[31:0] 主机 写数据总线用于写操作时主机向从机传输数据。推荐最小的位宽为32位。但是也很容易为了更高的带宽而进行扩展。 HSELx 译码器 每个AHB从机都拥有自己的选择信号，用于指示当前传输的目标是否是本从机。由简单的组合逻辑地址译码得到 HRDATA[31:0] 从机 读数据总线用于写操作时从机向主机传输数据。推荐最小的位宽为32位。但是也很容易为了更高的带宽而进行扩展。 HREADY 从机 高表示总线上的一次传输结束。为了扩展一次传输，该信号可被拉低。总线上的从机要求HREADY既有输入端口，又有输出端口。 HRESP[1:0] 从机 传输响应提供传输状态的额外信息。四种不同的响应为：OKAY，ERROR，RETRY，SPLIT AHB中还有一些信号用于支持多主机操作。这些仲裁信号的多数都是点到点的专用信号，表中后缀x表示信号来自模块x，如HBUSREQarm，HBUSREQdma等。 name source description HBUSREQx 主机 来自于主机x到仲裁器，用于表示主机请求使用总线。每个主机都有一个HBUSREQx，一个系统中最多有16个主机。 HLOCKx 主机 拉高表示主机请求执行总线锁定访问（locked access），而其他主机在该信号拉低之前不能获得总线。 HGRANTx 仲裁器 表示主机x当前拥有最高的总线优先级。地址/控制信号的所有权在一次传输以HREADY为高结束时改变，所以当HREADY（上一次访问结束）和HGRANTx都为高时获得总线。 HMASTER[3:0] 仲裁器 这个信号用于表明哪个主机正在进行传输，并被支持SPLIT传输的从机用于判断哪个主机正在尝试访问。HMASTER的时序与地址和控制信号的时序定义在一起。 HMASTERLOCK 仲裁器 表示当前主机进行的是锁定序列传输。具有与HMASTER一样的时序 HSPLITx[15:0] 从机 用于从机到仲裁器指示哪个主机需要允许事务拆分重传。每个位与一个单一的主机绑定。 传输类型、突发类型和响应类型传输类型（Transfer type）传输类型是HTRANS[1:0]信号的值编码，具体信息如下 HTRANS[1:0] 类型 描述 2’b00 IDLE 空闲状态，表示主机获得总线，但不想传输数据，从机在第一个IDLE周期时可以拉低HREADY向主机表示没有准备好接收该IDLE传输，一旦slave接收了一个IDLE，下一个周期无论HTRANS是什么，slave都不能拉低HREADY，必须立即接收，也就是slave当前周期接收了IDLE则下一个周期HREADY必须拉高，并且HRESP必须为OKAY 2’b01 BUSY 主机忙，表示主机没有准备好在下一个周期进行数据传输，slave可以在第一个BUSY周期时拉低HREADY，表示没有准备好接收该BUSY传输，一旦slave接收了一个BUSY，下一个周期无论HTRANS是什么，slave都不能拉低HREADY，必须立即接收，也就是slave当前周期接收了BUSY则下一个周期HREADY必须拉高，并且HRESP必须为OKAY 2’b10 NONSEQ 非连续传输，表示开始一个新传输，理论上认为该传输与前一个周期的传输无关，表示下一个周期进行一次新的传输，根据HBURST的不同而后续跟着不同数量的SEQ传输，如果HBURST是SINGLE，则没有后续的SEQ 2’b11 SEQ 连续传输，表示与前面的传输地址相关的连续的传输，具体的地址计算需要根据HBURST进行计算，当然slave也可以不计算，因为master每个周期都会给出地址 突发类型（Burst Type）传输类型是HBURST[2:0]信号的值编码，具体信息如下 HBURST[2:0] 类型 描述 3’b000 SINGLE 单次传输，NONSEQ后续没有SEQ，SINGLE的NONSEQ之后下一个周期不能是BUSY 3’b001 INCR 不指定长度的地址递增传输，传输数据的数量没有明确限制，但不能超过1KB边界 3’b010 WRAP4 4拍地址环回传输 3’b011 INCR4 4拍地址递增传输 3’b100 WRAP8 8拍地址环回传输 3’b101 INCR8 8拍地址递增传输 3’b110 WRAP16 16拍地址环回传输 3’b111 INCR16 16拍地址递增传输 slave响应类型（Response Type）slave在传输过程中需要向master传输一些响应信息，表示当前数据的结果和slave的状态 HRESP[1:0] 响应 描述 2’b00 OKAY 在HREADY为1时，表示数据传输成功完成，也用于非另外三种响应的HREADY为0时 2’b01 ERROR 用于表示当前有错误产生，slave本身和传输之一出现了问题，用于告诉master有错误出现，并且传输失败了；一次ERROR必须通过两个周期传输，第一个周期HREADY为0（为了让master做好准备），第二个周期HREADY为1 2’b10 RETRY slave告诉master当前传输未完成，master应该重试，直到传输成功；一次RETRY必须通过两个周期传输，第一个周期HREADY为0（为了让master做好准备），第二个周期HREADY为1 2’b11 SPLIT slave告诉master当前传输较长一段时间不能完成，master需要结束当前传输，等待下一次拿到总线再重试，slave在能够完成数据传输时会用HSPLITx信号通知仲裁器，让仲裁器将总线交给对应的master，当然如果一个更高优先级的传输正在进行时总线不会立即移交；一次SPLIT必须通过两个周期传输，第一个周期HREADY为0（为了让master做好准备），第二个周期HREADY为1 RETRY和SPLIT两种模式其实用的很少，因为这会增加slave的复杂程度，也会增加整个访问流程的复杂度。 HSIZE和地址计算HSIZE信号决定了一次突发传输过程中的数据位宽，HSIZE可以指定小于等于数据总线位宽的数据宽度 HSIZE[2:0] 大小 描述 3’b000 8 bits 1 Byte 3’b001 16 bits 1 Halfword 3’b010 32 bits 1 Word 3’b011 64 bits - 3’b100 128 bits 4 word line 3’b101 256 bits 8 word line 3’b110 512 bits - 3’b111 1024 bits - 如果数据总线位宽小于等于64位，HSIZE最高位可以不使用，HSIZE指定的位宽也是AHB可以支持的数据总线位宽。 如果HSIZE小于数据总线位宽时要区分大小端，我们来看一下，以下是AHB总线spec的例子，数据总线为32 bits 小端传输时如果HSIZE小于总线位宽，低位字节先传输，地址的增加按照HSIZE大小增加，低位字节的地址小于高位字节 大端传输时如果HSIZE小于总线位宽，高位字节先传输，地址的增加按照HSIZE大小增加，高位字节的地址小于低位字节 WARP传输的地址计算也是一个重要的环节，如果你的设计需要支持环回访问，需要计算出正确的地址： 根据spec的说法，wrap的环回地址边界是HSIZE×HBURST，比如： HBURST = WRAP4, HSIZE = Halfword, WRAP address = 4×2 = 8 HBURST = WRAP8, HSIZE = Word, WRAP address = 8 × 3 = 32 传输保护HPROT信号为传输提供了一些保护控制，包括cacheable, bufferable, privileged, data/opcode HPROT[3] HPROT[2] HPROT[1] HPROT[0] 描述 - - - 0 操作码拾取，对CPU而言 - - - 1 数据访问，对CPU及所有其他传输 - - 0 - 用户访问 - - 1 - 优先访问 - 0 - - Not bufferable，表示不可以在bus interconnect部分中被buffer - 1 - - Bufferable，表示可以在bus interconnect部分中被buffer 0 - - - Not cacheable，表示不可以在接收模块的cache中存储 1 - - - Cacheable，表示可以在接收模块的cache中存储 基本的传输波形INCR传输 INCR传输的地址都是按照HSIZE的大小递增的，具体的传输字节顺序可以参考前述的HSIZE章节。传输由1个NONSEQ和0个或多个SEQ传输组成，传输以下一个burst的NONSEQ或者IDLE结束，传输可以提前结束。 WRAP传输 WRAP传输的地址都是按照HSIZE的大小递增的，一直到环回地址边界时回到上一个边界处，具体的传输字节顺序可以参考前述的HSIZE章节。传输由1个NONSEQ和0个或多个SEQ传输组成，传输以下一个burst的NONSEQ或者IDLE结束，传输可以提前结束。","link":"/2024/11/09/AHB%E5%AD%A6%E4%B9%A0/"},{"title":"CRC算法","text":"CRC(Cyclic Redundancy Check)算法是一种数据校验算法，常用于数据完整性校验，由于其资源开销较低，容易进行数学分析并且尤其善于检测传输通道干扰引起的错误，而被广泛应用于各种传输协议、文件格式等方面。此方法是由W. Wesley Peterson于1961年发表。 基础算法循环冗余校验码是一种循环码，循环码具有以下特点： 码的结构可以用代数方法来构造和分析，并且可以找到各种实用的译码方法 由于其循环特性，编码运算和伴随式计算，可用反馈移位寄存器来实现，硬件实现简单 循环码的码字在循环移位后，仍是该循环码的码字 CRC码的表示通常我们以多项式来描述描述一个CRC码，常用的CRC多项式有： CRC算法 多项式公式 宽度 多项式 初始值 结果异或值 输入反转 输出反转 CRC-8 $x^8+x^2+x+1$ 8 07 00 00 false false CRC-8-ITU $x^8+x^2+x+1$ 8 07 00 55 false false CRC-8-ROHC $x^8+x^2+x+1$ 8 07 FF 00 true true CRC-8-MAXIM $x^8+x^5+x^4+1$ 8 31 00 00 true true CRC-16-IBM $x^{16}+x^{15}+x^2+1$ 16 8005 0000 0000 true true CRC-16-MAXIM $x^{16}+x^{15}+x^2+1$ 16 8005 0000 FFFF true true CRC-16-USB $x^{16}+x^{15}+x^2+1$ 16 8005 FFFF FFFF true true CRC-16-MODBUS $x^{16}+x^{15}+x^2+1$ 16 8005 FFFF 0000 true true CRC-16-CCITT $x^{16}+x^{12}+x^5+1$ 16 1021 0000 0000 true true CRC-16-CCITT-FALSE $x^{16}+x^{12}+x^5+1$ 16 1021 FFFF 0000 false false CRC-16-X^25 $x^{16}+x^{12}+x^5+1$ 16 1021 FFFF FFFF true true CRC-16-XMODEM $x^{16}+x^{12}+x^5+1$ 16 1021 0000 0000 false false CRC-16-XMODEM2 $x^{16}+x^{15}+x^10+x^3$ 16 8408 0000 0000 true true CRC-16-DNP $x^{16}+x^{13}+x^{12}+x^{11}+x^{10}+x^8+x^6+x^5+x^2+1$ 16 3D65 0000 FFFF true true CRC-32 $x^{32}+x^{26}+x^{23}+x^{22}+x^{16}+x^{12}+x^{11}+x^{10}+x^8+x^7+x^5+x^4+x^2+x+1$ 32 04C11DB7 FFFFFFFF FFFFFFFF true true CRC-32-C $x^{32}+x^{28}+x^{27}+x^{26}+x^{25}+x^{23}+x^{22}+x^{20}+x^{19}+x^{18}+x^{14}+x^{13}+x^{11}+x^{10}+x^9+x^8+x^6+1$ 32 1EDC6F41 FFFFFFFF FFFFFFFF true true CRC-32-KOOPMAN $x^{32}+x^{30}+x^{29}+x^{28}+x^{26}+x^{20}+x^{19}+x^{17}+x^{16}+x^{15}+x^{11}+x^{10}+x^7+x^6+x^4+x^2+x+1$ 32 741B8CD7 FFFFFFFF FFFFFFFF true true CRC-32-MPEG-2 $x^{32}+x^{26}+x^{23}+x^{22}+x^{16}+x^{12}+x^{11}+x^{10}+x^8+x^7+x^5+x^4+x^2+x+1$ 32 04C11DB7 FFFFFFFF 00000000 false false CRC-64-ISO $x^{64}+x^4+x^3+x+1$ 64 000000000000001B FFFFFFFFFFFFFFFF FFFFFFFFFFFFFFFF true true 如上表所示，一个CRC码可以使用多项式和多项式公式表示，多项式公式中一定包含最高次项和0次项，多项式中算上系数为0的项一共有n+1项，n是CRC的宽度，由于最高次项始终存在，所以我们在使用系数表达多项式时将其省略，比如04C11DB7实际上是104C11DB7 CRC的计算假设多项式为$x^8+x^2+x+1$，数据多项式为$x^3+x+1$ 多项式长除法： 数据乘以$x^{n-1}$，多项式最高次是8，所以乘以$x^{7}$，表示为$x^{10}+x^8+x^7$ 模2除法，CRC多项式最高次项不参与除法 $$\\begin{array}{lr} & x^8+x^7+x^6+x^5\\ \\ \\ \\ \\ \\ \\ \\ +x^3+x^2\\ \\ \\ \\ \\ \\ \\ \\ +1 \\\\ x^2+x+1 \\!\\!\\!\\!\\!\\! & \\overline{)x^{10}+\\ \\ \\ \\ \\ \\ \\ \\ \\ x^8+x^7\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ } \\\\ & \\underline{x^{10}+x^9+x^8}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\\\ & x^9+\\ \\ \\ \\ \\ \\ \\ \\ \\ x^7\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\\\ & \\underline{x^{9}+x^8+x^7}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\\\ & x^8\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\\\ & \\underline{x^{8}+x^7+x^6}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\\\ & {x^7+x^6}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\\\ & \\underline{x^7+x^6+x^5}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\\\ & {x^5}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\\\ & \\underline{x^5+x^4+x^3}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\\\ & {x^4+x^3}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\\\ & \\underline{x^4+x^3+x^2}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\\\ & {x^2}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\\\ & \\underline{x^2+x+1} \\\\ & {x+1} \\end{array}$$ 最终我们得到的结果多项式为：$x^{10}+x^9+x^8+x+1$ 二进制长除法 可以发现多项式长除法比较复杂，我们可以把多项式转换成一个二进制数再计算 $x^8+x^2+x+1 \\rightarrow 0111$ （省略最高位） $x^3+x+1 \\rightarrow 1011$ 数据左移n-1位：$1011 &lt;&lt; 7 = 10110000000$ $$\\begin{array}{lr} & 111101101 \\\\ 111 \\!\\!\\!\\!\\!\\! & \\overline{)10110000000} \\\\ & \\underline{111}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\\\ & 101\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\\\ & \\underline{111}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\\\ & {100}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\\\ & \\underline{111}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\\\ & {110}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\\\ & \\underline{111}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\\\ & {100}\\ \\ \\ \\ \\ \\ \\\\ & \\underline{111}\\ \\ \\ \\ \\ \\ \\\\ & {110}\\ \\ \\ \\ \\\\ & \\underline{111}\\ \\ \\ \\ \\\\ & {100} \\\\ & \\underline{111} \\\\ & {11} \\end{array}$$ 最终我们得到的结果为：$10110000011$ 以上两种方法得到的结果是一致的，我们可以对结果进行验算，如果我们计算的CRC是正确的，那么最后的结果再次计算CRC时余数为0 验算 $$\\begin{array}{lr} & 111101101 \\\\ 111 \\!\\!\\!\\!\\!\\! & \\overline{)10110000011} \\\\ & \\underline{111}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\\\ & 101\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\\\ & \\underline{111}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\\\ & {100}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\\\ & \\underline{111}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\\\ & {110}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\\\ & \\underline{111}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\\\ & {100}\\ \\ \\ \\ \\ \\ \\\\ & \\underline{111}\\ \\ \\ \\ \\ \\ \\\\ & {110}\\ \\ \\ \\ \\\\ & \\underline{111}\\ \\ \\ \\ \\\\ & {111} \\\\ & \\underline{111} \\\\ & {0} \\end{array}$$ 编程实现通过观察上一节中的二进制长除法CRC计算，我们可以将计算过程总结为： 剩余数据的最高位为1，则将数据高位XOR上CRC多项式 剩余数据的最高位为0，将数据左移去掉最高位0 CRC多项式的高位0不影响CRC计算 伪代码实现如下： 12345678910111213char crc_data = 0 ; // 初始值char poly = 0x07 ;uint_32 data = 0x12345 ;data ^= crc_data ;for(int i=0; i&lt;32; i++){ if(data &amp; 0x80000000){ data ^= (poly &lt;&lt; 24) ; } else { data &lt;&lt;= 1 ; }}crc_data = (data &gt;&gt; 24) ; 实际上CRC算法的研究已经相当成熟了，如果我们要使用硬件实现CRC的计算，我们可以参考Evgeni的Parallel CRC Generator，他还为我们提供了硬件代码生成器（Verilog和VHDL），如果你对并行CRC算法感兴趣的话可以阅读Parallel CRC Generator的内容，虽然我不知道这位大佬是如何推导出来的，但是我拜读完这篇文章后觉得惊为天人 CRC杂项初始值我们可以在使用CRC算法时指定不同的初始值，常见的值有全0和全1。实际上我们可以认为初始值也是某一段数据在初始值为0的基础上算出来的CRC，我们使用该CRC为基础然后继续计算后续的CRC 输入输出反转初次遇到这个概念时，可能会误解为将输入输出按位取反，实际上这个概念表示的是将输入输出的比特顺序反转，这样做的目的是使系统中的多个不同输入位宽的CRC运算单元能够按照相同的位顺序计算CRC，也就是说能够使得不同位宽的CRC云端单元的运算结果保持一致 大端系统 如果系统中传输时数据的高位先传（地址小），那么该系统就是大端系统，那么我们在计算CRC时不需要反转输入数据，输出数据的反转可以按需选择 小端系统 如果系统中传输时数据的低位先传（地址小），那么该系统就是小端系统，那么我们在计算CRC时需要反转输入数据，输出数据的反转可以按需选择 输出异或输出数据可以进行异或操作，常见的异或值有全1、全0和01交替 CRC计算网站如下是两个常用的CRC计算网站： http://www.ip33.com/crc.html https://www.lddgo.net/encrypt/crc 这两个网站的计算方式是一致的，需要注意的是如果需要对输入数据进行反转，除了需要勾选网页中的输入反转选项之外，还需要将数据输入框中的数据按照Byte进行顺序反转，才能符合上面我们提到的反转要求","link":"/2024/11/10/CRC%E7%AE%97%E6%B3%95/"}],"tags":[],"categories":[]}