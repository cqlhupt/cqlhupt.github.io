---
title: CRC算法
date: 2024-11-10 12:43:42
tags:
math: true
---
CRC(Cyclic Redundancy Check)算法是一种数据校验算法，常用于数据完整性校验，由于其资源开销较低，容易进行数学分析并且尤其善于检测传输通道干扰引起的错误，而被广泛应用于各种传输协议、文件格式等方面。此方法是由W. Wesley Peterson于1961年发表。
<!--more-->
# 基础算法
循环冗余校验码是一种循环码，循环码具有以下特点：

* 码的结构可以用代数方法来构造和分析，并且可以找到各种实用的译码方法
* 由于其循环特性，编码运算和伴随式计算，可用反馈移位寄存器来实现，硬件实现简单
* 循环码的码字在循环移位后，仍是该循环码的码字

## CRC码的表示

通常我们以多项式来描述描述一个CRC码，常用的CRC多项式有：

|CRC算法|多项式公式|宽度|多项式|初始值|结果异或值|输入反转|输出反转|
|---|---|---|---|---|---|---|---|
|CRC-8|$x^8+x^2+x+1$|8|07|00|00|false|false|
|CRC-8-ITU|$x^8+x^2+x+1$|8|07|00|55|false|false|
|CRC-8-ROHC|$x^8+x^2+x+1$|8|07|FF|00|true|true|
|CRC-8-MAXIM|$x^8+x^5+x^4+1$|8|31|00|00|true|true|
|CRC-16-IBM|$x^{16}+x^{15}+x^2+1$|16|8005|0000|0000|true|true|
|CRC-16-MAXIM|$x^{16}+x^{15}+x^2+1$|16|8005|0000|FFFF|true|true|
|CRC-16-USB|$x^{16}+x^{15}+x^2+1$|16|8005|FFFF|FFFF|true|true|
|CRC-16-MODBUS|$x^{16}+x^{15}+x^2+1$|16|8005|FFFF|0000|true|true|
|CRC-16-CCITT|$x^{16}+x^{12}+x^5+1$|16|1021|0000|0000|true|true|
|CRC-16-CCITT-FALSE|$x^{16}+x^{12}+x^5+1$|16|1021|FFFF|0000|false|false|
|CRC-16-X^25|$x^{16}+x^{12}+x^5+1$|16|1021|FFFF|FFFF|true|true|
|CRC-16-XMODEM|$x^{16}+x^{12}+x^5+1$|16|1021|0000|0000|false|false|
|CRC-16-XMODEM2|$x^{16}+x^{15}+x^10+x^3$|16|8408|0000|0000|true|true|
|CRC-16-DNP|$x^{16}+x^{13}+x^{12}+x^{11}+x^{10}+x^8+x^6+x^5+x^2+1$|16|3D65|0000|FFFF|true|true|
|CRC-32|$x^{32}+x^{26}+x^{23}+x^{22}+x^{16}+x^{12}+x^{11}+x^{10}+x^8+x^7+x^5+x^4+x^2+x+1$|32|04C11DB7|FFFFFFFF|FFFFFFFF|true|true|
|CRC-32-C|$x^{32}+x^{28}+x^{27}+x^{26}+x^{25}+x^{23}+x^{22}+x^{20}+x^{19}+x^{18}+x^{14}+x^{13}+x^{11}+x^{10}+x^9+x^8+x^6+1$|32|1EDC6F41|FFFFFFFF|FFFFFFFF|true|true|
|CRC-32-KOOPMAN|$x^{32}+x^{30}+x^{29}+x^{28}+x^{26}+x^{20}+x^{19}+x^{17}+x^{16}+x^{15}+x^{11}+x^{10}+x^7+x^6+x^4+x^2+x+1$|32|741B8CD7|FFFFFFFF|FFFFFFFF|true|true|
|CRC-32-MPEG-2|$x^{32}+x^{26}+x^{23}+x^{22}+x^{16}+x^{12}+x^{11}+x^{10}+x^8+x^7+x^5+x^4+x^2+x+1$|32|04C11DB7|FFFFFFFF|00000000|false|false|
|CRC-64-ISO|$x^{64}+x^4+x^3+x+1$|64|000000000000001B|FFFFFFFFFFFFFFFF|FFFFFFFFFFFFFFFF|true|true|
<!-- |CRC-64-ECMA|$x^64+x^62+x^57+x^55+x^54+x^53+x^52+x^47+x^46+x^45+x^40+x^39+x^38+x^37+x^35+x^33+x^32+x^31+x^29+x^27+x^24+x^23+x^22+x^21+x^19+x^17+x^13+x^12+x^10+x^9+x^7+x^4+x+1$|64|42F0E1EBA9EA3693|FFFFFFFFFFFFFFFF|FFFFFFFFFFFFFFFF|true|true| -->

如上表所示，一个CRC码可以使用多项式和多项式公式表示，多项式公式中一定包含最高次项和0次项，多项式中算上系数为0的项一共有n+1项，n是CRC的宽度，由于最高次项始终存在，所以我们在使用系数表达多项式时将其省略，比如04C11DB7实际上是104C11DB7

## CRC的计算


假设多项式为$x^8+x^2+x+1$，数据多项式为$x^3+x+1$

**多项式长除法：**

* 数据乘以$x^{n-1}$，多项式最高次是8，所以乘以$x^{7}$，表示为$x^{10}+x^8+x^7$
* 模2除法，CRC多项式最高次项不参与除法

<div>
$$\begin{array}{lr} 
& x^8+x^7+x^6+x^5\ \ \ \ \ \ \ \ +x^3+x^2\ \ \ \ \ \ \ \ +1 \\
x^2+x+1  \!\!\!\!\!\! & \overline{)x^{10}+\ \ \ \ \ \ \ \ \ x^8+x^7\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ } \\ 
& \underline{x^{10}+x^9+x^8}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \\ 
& x^9+\ \ \ \ \ \ \ \ \ x^7\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \\
& \underline{x^{9}+x^8+x^7}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \\ 
& x^8\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \\
& \underline{x^{8}+x^7+x^6}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \\ 
& {x^7+x^6}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \\ 
& \underline{x^7+x^6+x^5}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \\ 
& {x^5}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \\ 
& \underline{x^5+x^4+x^3}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \\ 
& {x^4+x^3}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \\ 
& \underline{x^4+x^3+x^2}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \\ 
& {x^2}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \\ 
& \underline{x^2+x+1} \\ 
& {x+1} 
\end{array}$$
</div>

最终我们得到的结果多项式为：$x^{10}+x^9+x^8+x+1$

**二进制长除法**

可以发现多项式长除法比较复杂，我们可以把多项式转换成一个二进制数再计算

* $x^8+x^2+x+1 \rightarrow 0111$ （省略最高位）
* $x^3+x+1 \rightarrow 1011$ 
* 数据左移n-1位：$1011 << 7 = 10110000000$
<div>
$$\begin{array}{lr} 
& 111101101 \\
111  \!\!\!\!\!\! & \overline{)10110000000} \\ 
& \underline{111}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \\ 
& 101\ \ \ \ \ \ \ \ \ \ \ \ \ \  \\
& \underline{111}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \\
& {100}\ \ \ \ \ \ \ \ \ \ \ \  \\ 
& \underline{111}\ \ \ \ \ \ \ \ \ \ \ \  \\ 
& {110}\ \ \ \ \ \ \ \ \ \  \\ 
& \underline{111}\ \ \ \ \ \ \ \ \ \  \\ 
& {100}\ \ \ \ \ \  \\ 
& \underline{111}\ \ \ \ \ \  \\ 
& {110}\ \ \ \  \\ 
& \underline{111}\ \ \ \  \\ 
& {100} \\ 
& \underline{111} \\ 
& {11} 
\end{array}$$
</div>
最终我们得到的结果为：$10110000011$

以上两种方法得到的结果是一致的，我们可以对结果进行验算，如果我们计算的CRC是正确的，那么最后的结果再次计算CRC时余数为0

**验算**
<div>
$$\begin{array}{lr} 
& 111101101 \\
111  \!\!\!\!\!\! & \overline{)10110000011} \\ 
& \underline{111}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \\ 
& 101\ \ \ \ \ \ \ \ \ \ \ \ \ \  \\
& \underline{111}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \\
& {100}\ \ \ \ \ \ \ \ \ \ \ \  \\ 
& \underline{111}\ \ \ \ \ \ \ \ \ \ \ \  \\ 
& {110}\ \ \ \ \ \ \ \ \ \  \\ 
& \underline{111}\ \ \ \ \ \ \ \ \ \  \\ 
& {100}\ \ \ \ \ \  \\ 
& \underline{111}\ \ \ \ \ \  \\ 
& {110}\ \ \ \  \\ 
& \underline{111}\ \ \ \  \\ 
& {111} \\ 
& \underline{111} \\ 
& {0} 
\end{array}$$
</div>

# 编程实现

通过观察上一节中的二进制长除法CRC计算，我们可以将计算过程总结为：

* 剩余数据的最高位为1，则将数据高位XOR上CRC多项式
* 剩余数据的最高位为0，将数据左移去掉最高位0
* CRC多项式的高位0不影响CRC计算

伪代码实现如下：
```C
char crc_data = 0 ; // 初始值
char poly = 0x07 ;
uint_32 data = 0x12345 ;

data ^= crc_data ;
for(int i=0; i<32; i++){
    if(data & 0x80000000){
        data ^= (poly << 24) ;
    } else {
        data <<= 1 ;
    }
}
crc_data = (data >> 24) ;
```

实际上CRC算法的研究已经相当成熟了，如果我们要使用硬件实现CRC的计算，我们可以参考Evgeni的[Parallel CRC Generator](https://outputlogic.com/?p=158)，他还为我们提供了[硬件代码生成器](http://outputlogic.com/?page_id=321)（Verilog和VHDL），如果你对并行CRC算法感兴趣的话可以阅读[Parallel CRC Generator](https://outputlogic.com/?p=158)的内容，虽然我不知道这位大佬是如何推导出来的，但是我拜读完这篇文章后觉得惊为天人

# CRC杂项
## 初始值

我们可以在使用CRC算法时指定不同的初始值，常见的值有全0和全1。实际上我们可以认为初始值也是某一段数据在初始值为0的基础上算出来的CRC，我们使用该CRC为基础然后继续计算后续的CRC

## 输入输出反转

初次遇到这个概念时，可能会误解为将输入输出按位取反，实际上这个概念表示的是将输入输出的比特顺序反转，这样做的目的是使系统中的多个不同输入位宽的CRC运算单元能够按照相同的位顺序计算CRC，也就是说能够使得不同位宽的CRC云端单元的运算结果保持一致

**大端系统**

如果系统中传输时数据的高位先传（地址小），那么该系统就是大端系统，那么我们在计算CRC时**不需要反转**输入数据，输出数据的反转可以按需选择

![大端系统数据传输顺序](/img/crc/big_endian.png "大端系统数据传输顺序")

**小端系统**

如果系统中传输时数据的低位先传（地址小），那么该系统就是小端系统，那么我们在计算CRC时**需要反转**输入数据，输出数据的反转可以按需选择

![小端系统数据传输顺序](/img/crc/little_endian.png "小端系统数据传输顺序")

## 输出异或
输出数据可以进行异或操作，常见的异或值有全1、全0和01交替

# CRC计算网站
如下是两个常用的CRC计算网站：

* http://www.ip33.com/crc.html
* https://www.lddgo.net/encrypt/crc

这两个网站的计算方式是一致的，需要注意的是如果需要对输入数据进行反转，除了需要勾选网页中的输入反转选项之外，还需要将数据输入框中的数据按照Byte进行顺序反转，才能符合上面我们提到的反转要求